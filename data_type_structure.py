# -*- coding: utf-8 -*-
"""data_type_structure.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_jhqdSHPyp4p-aFXCCbSdAUW_TWAWOWO

# *Data Types and Structures Questions*

1. What are data structures, and why are they important?
  - Data structures are a way of organizing and storing data in a computer so that it can be accessed and modified efficiently. They are a fundamental part of computer science and are used in almost every program or software system.

- They are important because they enable us to:

- Organize data effectively: A well-chosen data structure can make it easier to store, manage, and retrieve information.

- Improve efficiency: Different data structures are optimized for different operations. For example, a hash table is great for fast lookups, while a balanced binary search tree is good for sorted data.

- Solve problems: Data structures are the building blocks for more complex algorithms. By choosing the right structure, you can design a more efficient and elegant solution to a problem.

2. Explain the difference between mutable and immutable data types with examples.
- Mutable data types are those that can be changed after they are created. This means you can modify their content without creating a new object.
Examples: Lists, dictionaries, sets

- Immutable data types are those that cannot be changed after they are created. If you want to modify an immutable object, you must create a new one.
Examples: Integers, floats, strings, tuples.

3. What are the main differences between lists and tuples in Python?

> Mutability
- List → Mutable (you can change, add, or remove elements).
- my_list = [1, 2, 3]
- my_list[0] = 10      # ✅ Works
- my_list.append(4)    # ✅ Works
- Tuple → Immutable (once created, you cannot modify elements).
- my_tuple = (1, 2, 3)
- my_tuple[0] = 10   # ❌ Error

> Syntax
- List → Created with square brackets [].
- my_list = [1, 2, 3]
- Tuple → Created with parentheses ()..
my_tuple = (1, 2, 3)

> Performance

- List → Slower, because it needs extra memory for dynamic changes.
- Tuple → Faster, since it’s fixed and optimized internally.

> Use Cases

- List → Use when you need a collection that can change. Example: storing user inputs, items in a cart, etc.

- Tuple → Use when you need a fixed collection. Example: coordinates (x, y), days of the week, configuration values.

> Methods Available

- List → Has many built-in methods like .append(), .remove(), .sort().
- Tuple → Has very few methods (.count(), .index() only).

>Hashability

- Tuple → Can be used as dictionary keys or in sets if it contains only immutable elements.
- List → Cannot be used as dictionary keys or in sets.


4.  Describe how dictionaries store data.
- Dictionaries in Python store data as key-value pairs. Each unique key is associated with a specific value. They are implemented using a hash table, which allows for very fast lookups, insertions, and deletions.

> How it works:
- When you add a new key-value pair, the dictionary calculates a hash value (an integer) from the key.
- This hash value is used to determine where to store the key-value pair in an underlying array.
- When you want to retrieve a value, the dictionary re-calculates the hash of the key and uses it to quickly find the value's location.
> Example:
>- my_dict = {"name": "Alice", "age": 30, "city": "New York"}
>-  "name" is the key, "Alice" is the value.
>-  To access the value "Alice", you use its key:
>-  print(my_dict["name"]) # Output: Alice

5. Why might you use a set instead of a list in Python?
- You might use a set instead of a list for the following reasons:
>- Uniqueness: Sets only store unique elements. If you add an element that already exists in the set, it will be ignored. This makes sets ideal for removing duplicate values from a collection.
>- Fast Membership Testing: Checking if an item is present in a set ('item' in my_set) is, on average, much faster than doing the same check in a list. This is because sets are implemented using hash tables.
>- Mathematical Operations: Sets support mathematical operations like union, intersection, difference, and symmetric difference, which are not directly available for lists.

6. What is a string in Python, and how is it different from a list?
- A string in Python is an immutable sequence of characters, used to represent text. It's a fundamental data type.
>- The key differences between a string and a list are:
Mutability: Strings are immutable, meaning their content cannot be changed after creation. Lists are mutable, so you can add, remove, or modify elements.
>- Data Type: A string is a sequence of characters. A list is a sequence of objects, which can be of different data types (e.g., integers, strings, other lists).
>- Syntax: Strings are defined using single or double quotes ('hello' or "world"). Lists are defined using square brackets ([1, 2, 'three']).

7. How do tuples ensure data integrity in Python?
- Tuples are immutable, which is the primary way they ensure data integrity. Since you cannot change, add, or remove elements from a tuple after it's created, you can be certain that the data within it remains consistent and unaltered. This makes tuples ideal for storing data that should not be changed, such as coordinate pairs, database records, or configuration settings.

8. What is a hash table, and how does it relate to dictionaries in Python?
- A hash table is a data structure that stores data in key-value pairs. It uses a hash function to compute an index into an array of buckets or slots, from which the desired value can be found.
>-Python's dictionaries are implemented using a hash table. When you add a key-value pair to a dictionary, Python calculates the key's hash value to determine where to store the value. This allows for very fast lookup, insertion, and deletion of items.

9. Can lists contain different data types in Python?
- Yes, lists in Python can contain different data types. They are a heterogeneous collection. For example, a list can contain integers, floats, strings, and even other lists or tuples.
>- Example: my_list = [10, 'hello', 3.14, [1, 2]]

10. Explain why strings are immutable in Python.
- Strings are immutable in Python for several reasons, primarily related to performance and security:
>- Efficiency: When a string is created, Python can allocate a fixed amount of memory for it. Since it can't be changed, Python doesn't need to worry about reallocating memory if the string's size changes. This makes string operations like copying and hashing more efficient.
>- Security and Thread Safety: Immutability makes strings thread-safe. Multiple threads can read from the same string object without the risk of one thread modifying it while another is using it.
>- Use in Dictionaries and Sets: Because strings are immutable and hashable, they can be used as keys in dictionaries and as elements in sets. If strings were mutable, their hash value could change, breaking the integrity of these data structures.

11. What advantages do dictionaries offer over lists for certain tasks?
- Dictionaries are superior to lists for tasks that involve fast, non-sequential lookups based on a unique identifier (a key).
>- Fast Lookups: Dictionaries provide nearly constant time complexity (O(1) on average) for retrieving a value based on its key, while lists require a linear search (O(n)) if you don't know the index.
>- Readability: Using descriptive keys (e.g., 'name', 'age') makes the code more readable and self-documenting compared to accessing elements by an arbitrary index.
>- Flexibility: Dictionaries can be used to model real-world objects with attributes, like a person's name, age, and city, making them a more natural choice for this type of data.

12. Describe a scenario where using a tuple would be preferable over a list.
- A tuple would be preferable over a list when you are storing a collection of items that should not be changed, and where the position of the data is meaningful.
>- Example Scenario: Storing the coordinates of a point in a 2D plane.
- A point is represented by a pair of (x,y) coordinates. These values should not be modified once the point is created. Using a tuple point = (10, 20) ensures that you cannot accidentally change the x or y value, thereby maintaining the integrity of the point's location. If you used a list point = [10, 20], you could accidentally change point[0] = 5, which could lead to subtle bugs.

13. How do sets handle duplicate values in Python?
- Sets are unordered collections of unique elements. When you add a duplicate value to a set, it is simply ignored. Sets automatically handle the de-duplication of elements.
>-Example:
>- Python
>>- my_set = {1, 2, 3, 2, 1}
print(my_set)
>-Output: {1, 2, 3}
14. How does the “in” keyword work differently for lists and dictionaries?
- The in keyword checks for the presence of an element.
> For Lists: element in my_list checks if the element is one of the values within the list. It performs a linear search, which can be slow for large lists (O(n)).
> For Dictionaries: key in my_dict checks if the key exists in the dictionary. It does not check for values. This operation is very fast, with an average time complexity of O(1), because it uses the hash table to directly look up the key.

15. Can you modify the elements of a tuple? Explain why or why not.
- No, you cannot modify the elements of a tuple. This is because tuples are immutable. Once a tuple is created, its contents and structure are fixed. You cannot add, remove, or change any of the elements. This immutability is what guarantees data integrity and allows tuples to be used as dictionary keys.

16. What is a nested dictionary, and give an example of its use case.
- A nested dictionary is a dictionary where the values are themselves dictionaries. This allows you to create more complex, hierarchical data structures.
>- Use Case: Storing information about multiple users, where each user has a set of attributes.

17. Describe the time complexity of accessing elements in a dictionary.
- The time complexity of accessing elements in a dictionary is, on average, O(1) (constant time).
>- This is because dictionaries are implemented as hash tables. When you access an element using a key, Python uses a hash function to compute the memory address of the value. This process is extremely fast and does not depend on the size of the dictionary, making dictionaries highly efficient for lookups. In the worst-case scenario (due to hash collisions), the complexity can degrade to O(n), but this is very rare with Python's hash function.

18. In what situations are lists preferred over dictionaries?
- Lists are preferred over dictionaries in the following situations:
>- Ordered Data: When the order of elements is important and needs to be maintained.
>- Sequential Access: When you need to iterate through all elements in a specific order.
>- Collections of Similar Items: When you have a simple, ordered collection of items that don't need a unique identifier.
>- Mathematical Operations: When performing operations that rely on element position, such as finding the median or sorting.

19. Why are dictionaries considered unordered, and how does that affect data retrieval?
- Prior to Python 3.7, dictionaries were considered unordered because their internal hash table implementation did not preserve the insertion order of key-value pairs. The order in which items were stored was determined by the hash values, not the order of insertion.
>- Since Python 3.7, dictionaries do maintain insertion order. However, the conceptual difference remains important. Dictionaries are not designed for ordered access based on index like lists. Their primary purpose is fast retrieval by key. Relying on insertion order in older versions could lead to unpredictable results. Even with the new ordered behavior, the fundamental retrieval method is by key, not by position.

20. Explain the difference between a list and a dictionary in terms of data retrieval.
- List Data Retrieval: Data is retrieved by its index (its position) in the sequence. For example, my_list[0] retrieves the first element. Accessing a specific element by its value requires a linear search (O(n)).
>- Dictionary Data Retrieval: Data is retrieved by its key. For example, my_dict['name'] retrieves the value associated with the key 'name'. This is a constant-time operation on average (O(1)) due to the use of hash tables.

# ***Practical Questions*** ***bold text***
"""

#1.Create a string with your name and print it.
name = "Kaisarahmed"
print(name)

#2.Find the length of the string "Hello World"
my_string = "Hello World"
len(my_string)

#3.Slice the first 3 characters from the string "Python Programming"
my_string = "Python Programming"
sliced_string = my_string[0:3]
print(sliced_string)

#4.Convert the string "hello" to uppercase
my_str = "hello"
uppercase_str = my_str.upper()
print(uppercase_str)

#5.Replace "apple" with "orange" in the string "I like apple"
my_str = "I like apple"
new_str = my_str.replace("apple","orange")
print(new_str)

#6.Create a list with numbers 1 to 5 and print it
my_list = [1, 2, 3, 4, 5]
print(my_list)

#7.Append the number 10 to the list [1, 2, 3, 4]
my_list = [1, 2, 3, 4, 5]
my_list.append(10)
print(my_list)

#8.Remove the number 3 from the list [1, 2, 3, 4, 5]
my_list = [1, 2, 3, 4, 5]
my_list.remove(3)
print(my_list)

#9.Access the second element in the list ['a', 'b', 'c', 'd']
my_list = ['a', 'b', 'c', 'd']
second_element = my_list[1]
print(second_element)

#10.Reverse the list [10, 20, 30, 40, 50]
my_list = [10, 20, 30, 40, 50]
my_list.reverse()
print(my_list)

#11.Create a tuple with the elements 100, 200, 300 and print it.
tuple = (100, 200, 300)
print(tuple)

#12.Access the second-to-last element of the tuple ('red', 'green', 'blue', 'yellow').
my_tuple = ('red', 'green', 'blue', 'yellow')
element = my_tuple[-2]
print(element)

#13.Find the minimum number in the tuple (10, 20, 5, 15).
my_tuple = (10, 20, 5, 15)
minimum_num =min(my_tuple)
print(minimum_num)

#14.Find the index of the element "cat" in the tuple ('dog', 'cat', 'rabbit').
my_tuple = ('dog', 'cat', 'rabbit')
index = my_tuple.index('cat')
print(index)

#15.Create a tuple containing three different fruits and check if "kiwi" is in it.
my_fruits = ("apple", "banana", "orange")
is_kiwi_is_in_tuple = "kiwi" in my_fruits
print(is_kiwi_is_in_tuple)

#16.Create a set with the elements 'a', 'b', 'c' and print it.
my_set = {'a', 'b', 'c'}
print(my_set)

#17.Clear all elements from the set {1, 2, 3, 4, 5}.
my_elements = {1, 2, 3, 4, 5}
my_elements.clear()
print(my_elements)

#18.Remove the element 4 from the set {1, 2, 3, 4}.
my_elements = {1, 2, 3, 4, 5}
my_elements.remove(4)
print(my_elements)

#19.Find the union of two sets {1, 2, 3} and {3, 4, 5}.
set1 = {1, 2, 3}
set2 = {3, 4, 5}
my_union = set1.union(set2)
print(my_union)

#20.Find the intersection of two sets {1, 2, 3} and {2, 3, 4}.
set1 = {1, 2, 3}
set2 = {2, 3, 4}
my_intersection = set1.intersection(set2)
print(my_intersection)

#21.Write a code to create a dictionary with the keys "name", "age", and "city", and print it.
my_dictionary = {"name":"Kaiserahmed", "age":28, "city":"Siruguppa"}
print(my_dictionary)

#22.Write a code to add a new key-value pair "country": "USA" to the dictionary {'name': 'John', 'age': 25}.
my_dict = {'name':'John', 'age':25, }
my_dict['country'] = 'USA'
print(my_dict)

#23.Write a code to access the value associated with the key "name" in the dictionary {'name': 'Alice', 'age': 30}.
my_dict = {'name': 'Alice', 'age': 30}
name_value = my_dict['name']
print(name_value)

#24.Write a code to remove the key "age" from the dictionary {'name': 'Bob', 'age': 22, 'city': 'New York'}.
my_dict = {'name': 'Bob', 'age': 22, 'city': 'New York'}
del my_dict['age']
print(my_dict)

#25.Write a code to check if the key "city" exists in the dictionary {'name': 'Alice', 'city': 'Paris'}. Write a code to create a list, a tuple, and a dictionary, and print them all.
my_dict = {'name': 'Alice', 'city': 'Paris'}
if 'city' in my_dict :
  print("The key 'city' exists in the dictionary.")
else :
  print("The key 'city' dose not exists in the dictionary.")

#26.Write a code to create a list of 5 random numbers between 1 and 100, sort it in ascending order, and print the result. (replaced)
import random

random_numbers = [random.randint(1, 100) for _ in range(5)]
random_numbers.sort()
print(random_numbers)

#27.Write a code to create a list with strings and print the element at the third index
my_list = ["apple", "banana", "cherry", "date", "elderberry"]
third_element = my_list[2] # Remember that list indices start at 0
print(third_element)

#28.Write a code to combine two dictionaries into one and print the result.
dict1 = {'a': 1, 'b': 2}
dict2 = {'c': 3, 'd': 4}
combined_dict = {**dict1, **dict2}
print(combined_dict)

#29.Write a code to convert a list of strings into a set
my_list = ["apple", "banana", "cherry", "apple", "banana"]
my_set = set(my_list)
print(my_set)

#30.Write a code to check if the key "city" exists in the dictionary {'name': 'Alice', 'city': 'Paris'}. Write a code to create a list, a tuple, and a dictionary, and print them all.
my_dict = {'name': 'Alice', 'city': 'Paris'}
if 'city' in my_dict:
    print("The key 'city' exists in the dictionary.")
else:
    print("The key 'city' does not exist in the dictionary.")

    my_list = [1, 2, 3]
my_tuple = (4, 5, 6)
my_dict = {'a': 1, 'b': 2}

print("List:", my_list)
print("Tuple:", my_tuple)
print("Dictionary:", my_dict)